# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: FileStream.proto
# plugin: python-betterproto
from dataclasses import dataclass
from datetime import datetime
from typing import AsyncIterator, Dict, Optional

import betterproto
from betterproto.grpc.grpclib_server import ServiceBase
import grpclib


class HashAlgorithm(betterproto.Enum):
    SHA1 = 0
    SHA256 = 1
    SHA384 = 2
    SHA512 = 3
    MD5 = 4


class SizeUnits(betterproto.Enum):
    BYTE = 0
    KILO_BYTE = 1
    MEGA_BYTE = 2
    GIGA_BYTE = 3


class HealthCheckResponseServingStatus(betterproto.Enum):
    UNKNOWN = 0
    SERVING = 1
    NOT_SERVING = 2
    SERVICE_UNKNOWN = 3


@dataclass(eq=False, repr=False)
class Image(betterproto.Message):
    frame_meta: "FrameMeta" = betterproto.message_field(1)
    image_chunk: "ImageChunk" = betterproto.message_field(2)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class ImageHash(betterproto.Message):
    file_hash: str = betterproto.string_field(1)
    hash_algorithm: "HashAlgorithm" = betterproto.enum_field(2)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class FrameMeta(betterproto.Message):
    frame_index: int = betterproto.uint32_field(1)
    epoch_timestamp: "EpochTimestamp" = betterproto.message_field(2, group="timestamp")
    proto_timestamp: datetime = betterproto.message_field(3, group="timestamp")
    image_hash: "ImageHash" = betterproto.message_field(4)
    frame_size: "MaxSize" = betterproto.message_field(5)
    x_axis_pixels: int = betterproto.uint32_field(9)
    y_axis_pixels: int = betterproto.uint32_field(10)
    image_bit_depth: int = betterproto.uint32_field(11)
    image_bit_depth_real: int = betterproto.uint32_field(12)
    camera_id: "CameraId" = betterproto.message_field(13)
    container_name: str = betterproto.string_field(6)
    xmp_meta: str = betterproto.string_field(7)
    exif_meta: str = betterproto.string_field(8)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class TransferResponse(betterproto.Message):
    image_hash: "ImageHash" = betterproto.message_field(1)
    size: int = betterproto.uint32_field(2)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class MaxSize(betterproto.Message):
    size: int = betterproto.uint32_field(1)
    unit: "SizeUnits" = betterproto.enum_field(2)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class ImageChunk(betterproto.Message):
    chunk_id: int = betterproto.uint32_field(1)
    frame_chunk: bytes = betterproto.bytes_field(2)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class EpochTimestamp(betterproto.Message):
    seconds: int = betterproto.uint64_field(1)
    milliseconds: float = betterproto.double_field(2)
    microseconds: float = betterproto.double_field(3)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class CameraId(betterproto.Message):
    camera_id: str = betterproto.string_field(1)
    lens_id: str = betterproto.string_field(2)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class HealthCheckRequest(betterproto.Message):
    service: str = betterproto.string_field(1)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class HealthCheckResponse(betterproto.Message):
    status: "HealthCheckResponseServingStatus" = betterproto.enum_field(1)

    def __post_init__(self) -> None:
        super().__post_init__()


class TransferStub(betterproto.ServiceStub):
    async def file_stream(
        self, *, frame_meta: "FrameMeta" = None, image_chunk: "ImageChunk" = None
    ) -> "TransferResponse":

        request = Image()
        if frame_meta is not None:
            request.frame_meta = frame_meta
        if image_chunk is not None:
            request.image_chunk = image_chunk

        return await self._unary_unary(
            "/filestream.Transfer/FileStream", request, TransferResponse
        )


class HealthStub(betterproto.ServiceStub):
    """
    Used by the server inside of a container to ensure that the system is ready
    and running.TODO: implement as per:
    https://github.com/grpc/grpc/blob/master/doc/health-checking.md
    https://medium.com/@github.gkarthiks/implementing-healthchecks-in-grpc-
    containers-for-kubernetes-d5049989ab12
    """

    async def check(self, *, service: str = "") -> "HealthCheckResponse":

        request = HealthCheckRequest()
        request.service = service

        return await self._unary_unary(
            "/filestream.Health/Check", request, HealthCheckResponse
        )

    async def watch(self, *, service: str = "") -> AsyncIterator["HealthCheckResponse"]:

        request = HealthCheckRequest()
        request.service = service

        async for response in self._unary_stream(
            "/filestream.Health/Watch",
            request,
            HealthCheckResponse,
        ):
            yield response


class TransferBase(ServiceBase):
    async def file_stream(
        self, frame_meta: "FrameMeta", image_chunk: "ImageChunk"
    ) -> "TransferResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_file_stream(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "frame_meta": request.frame_meta,
            "image_chunk": request.image_chunk,
        }

        response = await self.file_stream(**request_kwargs)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/filestream.Transfer/FileStream": grpclib.const.Handler(
                self.__rpc_file_stream,
                grpclib.const.Cardinality.UNARY_UNARY,
                Image,
                TransferResponse,
            ),
        }


class HealthBase(ServiceBase):
    """
    Used by the server inside of a container to ensure that the system is ready
    and running.TODO: implement as per:
    https://github.com/grpc/grpc/blob/master/doc/health-checking.md
    https://medium.com/@github.gkarthiks/implementing-healthchecks-in-grpc-
    containers-for-kubernetes-d5049989ab12
    """

    async def check(self, service: str) -> "HealthCheckResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def watch(self, service: str) -> AsyncIterator["HealthCheckResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_check(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "service": request.service,
        }

        response = await self.check(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_watch(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "service": request.service,
        }

        await self._call_rpc_handler_server_stream(
            self.watch,
            stream,
            request_kwargs,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/filestream.Health/Check": grpclib.const.Handler(
                self.__rpc_check,
                grpclib.const.Cardinality.UNARY_UNARY,
                HealthCheckRequest,
                HealthCheckResponse,
            ),
            "/filestream.Health/Watch": grpclib.const.Handler(
                self.__rpc_watch,
                grpclib.const.Cardinality.UNARY_STREAM,
                HealthCheckRequest,
                HealthCheckResponse,
            ),
        }

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: FileStream.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_FileStream_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_FileStream_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3014000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3014000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_FileStream_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_FileStream_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[10]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_FileStream_2eproto;
namespace filestream {
class CameraId;
class CameraIdDefaultTypeInternal;
extern CameraIdDefaultTypeInternal _CameraId_default_instance_;
class EpochTimestamp;
class EpochTimestampDefaultTypeInternal;
extern EpochTimestampDefaultTypeInternal _EpochTimestamp_default_instance_;
class FrameMeta;
class FrameMetaDefaultTypeInternal;
extern FrameMetaDefaultTypeInternal _FrameMeta_default_instance_;
class HealthCheckRequest;
class HealthCheckRequestDefaultTypeInternal;
extern HealthCheckRequestDefaultTypeInternal _HealthCheckRequest_default_instance_;
class HealthCheckResponse;
class HealthCheckResponseDefaultTypeInternal;
extern HealthCheckResponseDefaultTypeInternal _HealthCheckResponse_default_instance_;
class Image;
class ImageDefaultTypeInternal;
extern ImageDefaultTypeInternal _Image_default_instance_;
class ImageChunk;
class ImageChunkDefaultTypeInternal;
extern ImageChunkDefaultTypeInternal _ImageChunk_default_instance_;
class ImageHash;
class ImageHashDefaultTypeInternal;
extern ImageHashDefaultTypeInternal _ImageHash_default_instance_;
class MaxSize;
class MaxSizeDefaultTypeInternal;
extern MaxSizeDefaultTypeInternal _MaxSize_default_instance_;
class TransferResponse;
class TransferResponseDefaultTypeInternal;
extern TransferResponseDefaultTypeInternal _TransferResponse_default_instance_;
}  // namespace filestream
PROTOBUF_NAMESPACE_OPEN
template<> ::filestream::CameraId* Arena::CreateMaybeMessage<::filestream::CameraId>(Arena*);
template<> ::filestream::EpochTimestamp* Arena::CreateMaybeMessage<::filestream::EpochTimestamp>(Arena*);
template<> ::filestream::FrameMeta* Arena::CreateMaybeMessage<::filestream::FrameMeta>(Arena*);
template<> ::filestream::HealthCheckRequest* Arena::CreateMaybeMessage<::filestream::HealthCheckRequest>(Arena*);
template<> ::filestream::HealthCheckResponse* Arena::CreateMaybeMessage<::filestream::HealthCheckResponse>(Arena*);
template<> ::filestream::Image* Arena::CreateMaybeMessage<::filestream::Image>(Arena*);
template<> ::filestream::ImageChunk* Arena::CreateMaybeMessage<::filestream::ImageChunk>(Arena*);
template<> ::filestream::ImageHash* Arena::CreateMaybeMessage<::filestream::ImageHash>(Arena*);
template<> ::filestream::MaxSize* Arena::CreateMaybeMessage<::filestream::MaxSize>(Arena*);
template<> ::filestream::TransferResponse* Arena::CreateMaybeMessage<::filestream::TransferResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace filestream {

enum HealthCheckResponse_ServingStatus : int {
  HealthCheckResponse_ServingStatus_UNKNOWN = 0,
  HealthCheckResponse_ServingStatus_SERVING = 1,
  HealthCheckResponse_ServingStatus_NOT_SERVING = 2,
  HealthCheckResponse_ServingStatus_SERVICE_UNKNOWN = 3,
  HealthCheckResponse_ServingStatus_HealthCheckResponse_ServingStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  HealthCheckResponse_ServingStatus_HealthCheckResponse_ServingStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool HealthCheckResponse_ServingStatus_IsValid(int value);
constexpr HealthCheckResponse_ServingStatus HealthCheckResponse_ServingStatus_ServingStatus_MIN = HealthCheckResponse_ServingStatus_UNKNOWN;
constexpr HealthCheckResponse_ServingStatus HealthCheckResponse_ServingStatus_ServingStatus_MAX = HealthCheckResponse_ServingStatus_SERVICE_UNKNOWN;
constexpr int HealthCheckResponse_ServingStatus_ServingStatus_ARRAYSIZE = HealthCheckResponse_ServingStatus_ServingStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* HealthCheckResponse_ServingStatus_descriptor();
template<typename T>
inline const std::string& HealthCheckResponse_ServingStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, HealthCheckResponse_ServingStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function HealthCheckResponse_ServingStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    HealthCheckResponse_ServingStatus_descriptor(), enum_t_value);
}
inline bool HealthCheckResponse_ServingStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HealthCheckResponse_ServingStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<HealthCheckResponse_ServingStatus>(
    HealthCheckResponse_ServingStatus_descriptor(), name, value);
}
enum HashAlgorithm : int {
  SHA1 = 0,
  SHA256 = 1,
  SHA384 = 2,
  SHA512 = 3,
  MD5 = 4,
  HashAlgorithm_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  HashAlgorithm_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool HashAlgorithm_IsValid(int value);
constexpr HashAlgorithm HashAlgorithm_MIN = SHA1;
constexpr HashAlgorithm HashAlgorithm_MAX = MD5;
constexpr int HashAlgorithm_ARRAYSIZE = HashAlgorithm_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* HashAlgorithm_descriptor();
template<typename T>
inline const std::string& HashAlgorithm_Name(T enum_t_value) {
  static_assert(::std::is_same<T, HashAlgorithm>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function HashAlgorithm_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    HashAlgorithm_descriptor(), enum_t_value);
}
inline bool HashAlgorithm_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HashAlgorithm* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<HashAlgorithm>(
    HashAlgorithm_descriptor(), name, value);
}
enum SizeUnits : int {
  BYTE = 0,
  KILO_BYTE = 1,
  MEGA_BYTE = 2,
  GIGA_BYTE = 3,
  SizeUnits_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  SizeUnits_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool SizeUnits_IsValid(int value);
constexpr SizeUnits SizeUnits_MIN = BYTE;
constexpr SizeUnits SizeUnits_MAX = GIGA_BYTE;
constexpr int SizeUnits_ARRAYSIZE = SizeUnits_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SizeUnits_descriptor();
template<typename T>
inline const std::string& SizeUnits_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SizeUnits>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SizeUnits_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SizeUnits_descriptor(), enum_t_value);
}
inline bool SizeUnits_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SizeUnits* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SizeUnits>(
    SizeUnits_descriptor(), name, value);
}
// ===================================================================

class Image PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:filestream.Image) */ {
 public:
  inline Image() : Image(nullptr) {}
  virtual ~Image();

  Image(const Image& from);
  Image(Image&& from) noexcept
    : Image() {
    *this = ::std::move(from);
  }

  inline Image& operator=(const Image& from) {
    CopyFrom(from);
    return *this;
  }
  inline Image& operator=(Image&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Image& default_instance();

  static inline const Image* internal_default_instance() {
    return reinterpret_cast<const Image*>(
               &_Image_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Image& a, Image& b) {
    a.Swap(&b);
  }
  inline void Swap(Image* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Image* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Image* New() const final {
    return CreateMaybeMessage<Image>(nullptr);
  }

  Image* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Image>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Image& from);
  void MergeFrom(const Image& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Image* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "filestream.Image";
  }
  protected:
  explicit Image(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_FileStream_2eproto);
    return ::descriptor_table_FileStream_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFrameMetaFieldNumber = 1,
    kImageChunkFieldNumber = 2,
  };
  // .filestream.FrameMeta frameMeta = 1;
  bool has_framemeta() const;
  private:
  bool _internal_has_framemeta() const;
  public:
  void clear_framemeta();
  const ::filestream::FrameMeta& framemeta() const;
  ::filestream::FrameMeta* release_framemeta();
  ::filestream::FrameMeta* mutable_framemeta();
  void set_allocated_framemeta(::filestream::FrameMeta* framemeta);
  private:
  const ::filestream::FrameMeta& _internal_framemeta() const;
  ::filestream::FrameMeta* _internal_mutable_framemeta();
  public:
  void unsafe_arena_set_allocated_framemeta(
      ::filestream::FrameMeta* framemeta);
  ::filestream::FrameMeta* unsafe_arena_release_framemeta();

  // .filestream.ImageChunk imageChunk = 2;
  bool has_imagechunk() const;
  private:
  bool _internal_has_imagechunk() const;
  public:
  void clear_imagechunk();
  const ::filestream::ImageChunk& imagechunk() const;
  ::filestream::ImageChunk* release_imagechunk();
  ::filestream::ImageChunk* mutable_imagechunk();
  void set_allocated_imagechunk(::filestream::ImageChunk* imagechunk);
  private:
  const ::filestream::ImageChunk& _internal_imagechunk() const;
  ::filestream::ImageChunk* _internal_mutable_imagechunk();
  public:
  void unsafe_arena_set_allocated_imagechunk(
      ::filestream::ImageChunk* imagechunk);
  ::filestream::ImageChunk* unsafe_arena_release_imagechunk();

  // @@protoc_insertion_point(class_scope:filestream.Image)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::filestream::FrameMeta* framemeta_;
  ::filestream::ImageChunk* imagechunk_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_FileStream_2eproto;
};
// -------------------------------------------------------------------

class ImageHash PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:filestream.ImageHash) */ {
 public:
  inline ImageHash() : ImageHash(nullptr) {}
  virtual ~ImageHash();

  ImageHash(const ImageHash& from);
  ImageHash(ImageHash&& from) noexcept
    : ImageHash() {
    *this = ::std::move(from);
  }

  inline ImageHash& operator=(const ImageHash& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImageHash& operator=(ImageHash&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ImageHash& default_instance();

  static inline const ImageHash* internal_default_instance() {
    return reinterpret_cast<const ImageHash*>(
               &_ImageHash_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ImageHash& a, ImageHash& b) {
    a.Swap(&b);
  }
  inline void Swap(ImageHash* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImageHash* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ImageHash* New() const final {
    return CreateMaybeMessage<ImageHash>(nullptr);
  }

  ImageHash* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ImageHash>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ImageHash& from);
  void MergeFrom(const ImageHash& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImageHash* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "filestream.ImageHash";
  }
  protected:
  explicit ImageHash(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_FileStream_2eproto);
    return ::descriptor_table_FileStream_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileHashFieldNumber = 1,
    kHashAlgorithmFieldNumber = 2,
  };
  // string fileHash = 1;
  void clear_filehash();
  const std::string& filehash() const;
  void set_filehash(const std::string& value);
  void set_filehash(std::string&& value);
  void set_filehash(const char* value);
  void set_filehash(const char* value, size_t size);
  std::string* mutable_filehash();
  std::string* release_filehash();
  void set_allocated_filehash(std::string* filehash);
  private:
  const std::string& _internal_filehash() const;
  void _internal_set_filehash(const std::string& value);
  std::string* _internal_mutable_filehash();
  public:

  // .filestream.HashAlgorithm hashAlgorithm = 2;
  void clear_hashalgorithm();
  ::filestream::HashAlgorithm hashalgorithm() const;
  void set_hashalgorithm(::filestream::HashAlgorithm value);
  private:
  ::filestream::HashAlgorithm _internal_hashalgorithm() const;
  void _internal_set_hashalgorithm(::filestream::HashAlgorithm value);
  public:

  // @@protoc_insertion_point(class_scope:filestream.ImageHash)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filehash_;
  int hashalgorithm_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_FileStream_2eproto;
};
// -------------------------------------------------------------------

class FrameMeta PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:filestream.FrameMeta) */ {
 public:
  inline FrameMeta() : FrameMeta(nullptr) {}
  virtual ~FrameMeta();

  FrameMeta(const FrameMeta& from);
  FrameMeta(FrameMeta&& from) noexcept
    : FrameMeta() {
    *this = ::std::move(from);
  }

  inline FrameMeta& operator=(const FrameMeta& from) {
    CopyFrom(from);
    return *this;
  }
  inline FrameMeta& operator=(FrameMeta&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FrameMeta& default_instance();

  enum TimestampCase {
    kEpochTimestamp = 2,
    kProtoTimestamp = 3,
    TIMESTAMP_NOT_SET = 0,
  };

  static inline const FrameMeta* internal_default_instance() {
    return reinterpret_cast<const FrameMeta*>(
               &_FrameMeta_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(FrameMeta& a, FrameMeta& b) {
    a.Swap(&b);
  }
  inline void Swap(FrameMeta* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FrameMeta* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FrameMeta* New() const final {
    return CreateMaybeMessage<FrameMeta>(nullptr);
  }

  FrameMeta* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FrameMeta>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FrameMeta& from);
  void MergeFrom(const FrameMeta& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FrameMeta* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "filestream.FrameMeta";
  }
  protected:
  explicit FrameMeta(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_FileStream_2eproto);
    return ::descriptor_table_FileStream_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContainerNameFieldNumber = 6,
    kXmpMetaFieldNumber = 7,
    kExifMetaFieldNumber = 8,
    kImageHashFieldNumber = 4,
    kFrameSizeFieldNumber = 5,
    kCameraIdFieldNumber = 13,
    kFrameIndexFieldNumber = 1,
    kXAxisPixelsFieldNumber = 9,
    kYAxisPixelsFieldNumber = 10,
    kImageBitDepthFieldNumber = 11,
    kImageBitDepthRealFieldNumber = 12,
    kEpochTimestampFieldNumber = 2,
    kProtoTimestampFieldNumber = 3,
  };
  // string containerName = 6;
  void clear_containername();
  const std::string& containername() const;
  void set_containername(const std::string& value);
  void set_containername(std::string&& value);
  void set_containername(const char* value);
  void set_containername(const char* value, size_t size);
  std::string* mutable_containername();
  std::string* release_containername();
  void set_allocated_containername(std::string* containername);
  private:
  const std::string& _internal_containername() const;
  void _internal_set_containername(const std::string& value);
  std::string* _internal_mutable_containername();
  public:

  // string xmpMeta = 7;
  void clear_xmpmeta();
  const std::string& xmpmeta() const;
  void set_xmpmeta(const std::string& value);
  void set_xmpmeta(std::string&& value);
  void set_xmpmeta(const char* value);
  void set_xmpmeta(const char* value, size_t size);
  std::string* mutable_xmpmeta();
  std::string* release_xmpmeta();
  void set_allocated_xmpmeta(std::string* xmpmeta);
  private:
  const std::string& _internal_xmpmeta() const;
  void _internal_set_xmpmeta(const std::string& value);
  std::string* _internal_mutable_xmpmeta();
  public:

  // string exifMeta = 8;
  void clear_exifmeta();
  const std::string& exifmeta() const;
  void set_exifmeta(const std::string& value);
  void set_exifmeta(std::string&& value);
  void set_exifmeta(const char* value);
  void set_exifmeta(const char* value, size_t size);
  std::string* mutable_exifmeta();
  std::string* release_exifmeta();
  void set_allocated_exifmeta(std::string* exifmeta);
  private:
  const std::string& _internal_exifmeta() const;
  void _internal_set_exifmeta(const std::string& value);
  std::string* _internal_mutable_exifmeta();
  public:

  // .filestream.ImageHash imageHash = 4;
  bool has_imagehash() const;
  private:
  bool _internal_has_imagehash() const;
  public:
  void clear_imagehash();
  const ::filestream::ImageHash& imagehash() const;
  ::filestream::ImageHash* release_imagehash();
  ::filestream::ImageHash* mutable_imagehash();
  void set_allocated_imagehash(::filestream::ImageHash* imagehash);
  private:
  const ::filestream::ImageHash& _internal_imagehash() const;
  ::filestream::ImageHash* _internal_mutable_imagehash();
  public:
  void unsafe_arena_set_allocated_imagehash(
      ::filestream::ImageHash* imagehash);
  ::filestream::ImageHash* unsafe_arena_release_imagehash();

  // .filestream.MaxSize frameSize = 5;
  bool has_framesize() const;
  private:
  bool _internal_has_framesize() const;
  public:
  void clear_framesize();
  const ::filestream::MaxSize& framesize() const;
  ::filestream::MaxSize* release_framesize();
  ::filestream::MaxSize* mutable_framesize();
  void set_allocated_framesize(::filestream::MaxSize* framesize);
  private:
  const ::filestream::MaxSize& _internal_framesize() const;
  ::filestream::MaxSize* _internal_mutable_framesize();
  public:
  void unsafe_arena_set_allocated_framesize(
      ::filestream::MaxSize* framesize);
  ::filestream::MaxSize* unsafe_arena_release_framesize();

  // .filestream.CameraId cameraId = 13;
  bool has_cameraid() const;
  private:
  bool _internal_has_cameraid() const;
  public:
  void clear_cameraid();
  const ::filestream::CameraId& cameraid() const;
  ::filestream::CameraId* release_cameraid();
  ::filestream::CameraId* mutable_cameraid();
  void set_allocated_cameraid(::filestream::CameraId* cameraid);
  private:
  const ::filestream::CameraId& _internal_cameraid() const;
  ::filestream::CameraId* _internal_mutable_cameraid();
  public:
  void unsafe_arena_set_allocated_cameraid(
      ::filestream::CameraId* cameraid);
  ::filestream::CameraId* unsafe_arena_release_cameraid();

  // uint32 frameIndex = 1;
  void clear_frameindex();
  ::PROTOBUF_NAMESPACE_ID::uint32 frameindex() const;
  void set_frameindex(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_frameindex() const;
  void _internal_set_frameindex(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 xAxisPixels = 9;
  void clear_xaxispixels();
  ::PROTOBUF_NAMESPACE_ID::uint32 xaxispixels() const;
  void set_xaxispixels(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_xaxispixels() const;
  void _internal_set_xaxispixels(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 yAxisPixels = 10;
  void clear_yaxispixels();
  ::PROTOBUF_NAMESPACE_ID::uint32 yaxispixels() const;
  void set_yaxispixels(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_yaxispixels() const;
  void _internal_set_yaxispixels(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 imageBitDepth = 11;
  void clear_imagebitdepth();
  ::PROTOBUF_NAMESPACE_ID::uint32 imagebitdepth() const;
  void set_imagebitdepth(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_imagebitdepth() const;
  void _internal_set_imagebitdepth(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 imageBitDepthReal = 12;
  void clear_imagebitdepthreal();
  ::PROTOBUF_NAMESPACE_ID::uint32 imagebitdepthreal() const;
  void set_imagebitdepthreal(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_imagebitdepthreal() const;
  void _internal_set_imagebitdepthreal(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // .filestream.EpochTimestamp epochTimestamp = 2;
  bool has_epochtimestamp() const;
  private:
  bool _internal_has_epochtimestamp() const;
  public:
  void clear_epochtimestamp();
  const ::filestream::EpochTimestamp& epochtimestamp() const;
  ::filestream::EpochTimestamp* release_epochtimestamp();
  ::filestream::EpochTimestamp* mutable_epochtimestamp();
  void set_allocated_epochtimestamp(::filestream::EpochTimestamp* epochtimestamp);
  private:
  const ::filestream::EpochTimestamp& _internal_epochtimestamp() const;
  ::filestream::EpochTimestamp* _internal_mutable_epochtimestamp();
  public:
  void unsafe_arena_set_allocated_epochtimestamp(
      ::filestream::EpochTimestamp* epochtimestamp);
  ::filestream::EpochTimestamp* unsafe_arena_release_epochtimestamp();

  // .google.protobuf.Timestamp protoTimestamp = 3;
  bool has_prototimestamp() const;
  private:
  bool _internal_has_prototimestamp() const;
  public:
  void clear_prototimestamp();
  const PROTOBUF_NAMESPACE_ID::Timestamp& prototimestamp() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_prototimestamp();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_prototimestamp();
  void set_allocated_prototimestamp(PROTOBUF_NAMESPACE_ID::Timestamp* prototimestamp);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_prototimestamp() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_prototimestamp();
  public:
  void unsafe_arena_set_allocated_prototimestamp(
      PROTOBUF_NAMESPACE_ID::Timestamp* prototimestamp);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_prototimestamp();

  void clear_timestamp();
  TimestampCase timestamp_case() const;
  // @@protoc_insertion_point(class_scope:filestream.FrameMeta)
 private:
  class _Internal;
  void set_has_epochtimestamp();
  void set_has_prototimestamp();

  inline bool has_timestamp() const;
  inline void clear_has_timestamp();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr containername_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr xmpmeta_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr exifmeta_;
  ::filestream::ImageHash* imagehash_;
  ::filestream::MaxSize* framesize_;
  ::filestream::CameraId* cameraid_;
  ::PROTOBUF_NAMESPACE_ID::uint32 frameindex_;
  ::PROTOBUF_NAMESPACE_ID::uint32 xaxispixels_;
  ::PROTOBUF_NAMESPACE_ID::uint32 yaxispixels_;
  ::PROTOBUF_NAMESPACE_ID::uint32 imagebitdepth_;
  ::PROTOBUF_NAMESPACE_ID::uint32 imagebitdepthreal_;
  union TimestampUnion {
    TimestampUnion() {}
    ::filestream::EpochTimestamp* epochtimestamp_;
    PROTOBUF_NAMESPACE_ID::Timestamp* prototimestamp_;
  } timestamp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_FileStream_2eproto;
};
// -------------------------------------------------------------------

class TransferResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:filestream.TransferResponse) */ {
 public:
  inline TransferResponse() : TransferResponse(nullptr) {}
  virtual ~TransferResponse();

  TransferResponse(const TransferResponse& from);
  TransferResponse(TransferResponse&& from) noexcept
    : TransferResponse() {
    *this = ::std::move(from);
  }

  inline TransferResponse& operator=(const TransferResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransferResponse& operator=(TransferResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TransferResponse& default_instance();

  static inline const TransferResponse* internal_default_instance() {
    return reinterpret_cast<const TransferResponse*>(
               &_TransferResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(TransferResponse& a, TransferResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TransferResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransferResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TransferResponse* New() const final {
    return CreateMaybeMessage<TransferResponse>(nullptr);
  }

  TransferResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TransferResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TransferResponse& from);
  void MergeFrom(const TransferResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransferResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "filestream.TransferResponse";
  }
  protected:
  explicit TransferResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_FileStream_2eproto);
    return ::descriptor_table_FileStream_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImageHashFieldNumber = 1,
    kSizeFieldNumber = 2,
  };
  // .filestream.ImageHash imageHash = 1;
  bool has_imagehash() const;
  private:
  bool _internal_has_imagehash() const;
  public:
  void clear_imagehash();
  const ::filestream::ImageHash& imagehash() const;
  ::filestream::ImageHash* release_imagehash();
  ::filestream::ImageHash* mutable_imagehash();
  void set_allocated_imagehash(::filestream::ImageHash* imagehash);
  private:
  const ::filestream::ImageHash& _internal_imagehash() const;
  ::filestream::ImageHash* _internal_mutable_imagehash();
  public:
  void unsafe_arena_set_allocated_imagehash(
      ::filestream::ImageHash* imagehash);
  ::filestream::ImageHash* unsafe_arena_release_imagehash();

  // uint32 size = 2;
  void clear_size();
  ::PROTOBUF_NAMESPACE_ID::uint32 size() const;
  void set_size(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_size() const;
  void _internal_set_size(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:filestream.TransferResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::filestream::ImageHash* imagehash_;
  ::PROTOBUF_NAMESPACE_ID::uint32 size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_FileStream_2eproto;
};
// -------------------------------------------------------------------

class MaxSize PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:filestream.MaxSize) */ {
 public:
  inline MaxSize() : MaxSize(nullptr) {}
  virtual ~MaxSize();

  MaxSize(const MaxSize& from);
  MaxSize(MaxSize&& from) noexcept
    : MaxSize() {
    *this = ::std::move(from);
  }

  inline MaxSize& operator=(const MaxSize& from) {
    CopyFrom(from);
    return *this;
  }
  inline MaxSize& operator=(MaxSize&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MaxSize& default_instance();

  static inline const MaxSize* internal_default_instance() {
    return reinterpret_cast<const MaxSize*>(
               &_MaxSize_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(MaxSize& a, MaxSize& b) {
    a.Swap(&b);
  }
  inline void Swap(MaxSize* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MaxSize* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MaxSize* New() const final {
    return CreateMaybeMessage<MaxSize>(nullptr);
  }

  MaxSize* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MaxSize>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MaxSize& from);
  void MergeFrom(const MaxSize& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MaxSize* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "filestream.MaxSize";
  }
  protected:
  explicit MaxSize(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_FileStream_2eproto);
    return ::descriptor_table_FileStream_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSizeFieldNumber = 1,
    kUnitFieldNumber = 2,
  };
  // uint32 size = 1;
  void clear_size();
  ::PROTOBUF_NAMESPACE_ID::uint32 size() const;
  void set_size(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_size() const;
  void _internal_set_size(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // .filestream.SizeUnits unit = 2;
  void clear_unit();
  ::filestream::SizeUnits unit() const;
  void set_unit(::filestream::SizeUnits value);
  private:
  ::filestream::SizeUnits _internal_unit() const;
  void _internal_set_unit(::filestream::SizeUnits value);
  public:

  // @@protoc_insertion_point(class_scope:filestream.MaxSize)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 size_;
  int unit_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_FileStream_2eproto;
};
// -------------------------------------------------------------------

class ImageChunk PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:filestream.ImageChunk) */ {
 public:
  inline ImageChunk() : ImageChunk(nullptr) {}
  virtual ~ImageChunk();

  ImageChunk(const ImageChunk& from);
  ImageChunk(ImageChunk&& from) noexcept
    : ImageChunk() {
    *this = ::std::move(from);
  }

  inline ImageChunk& operator=(const ImageChunk& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImageChunk& operator=(ImageChunk&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ImageChunk& default_instance();

  static inline const ImageChunk* internal_default_instance() {
    return reinterpret_cast<const ImageChunk*>(
               &_ImageChunk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ImageChunk& a, ImageChunk& b) {
    a.Swap(&b);
  }
  inline void Swap(ImageChunk* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImageChunk* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ImageChunk* New() const final {
    return CreateMaybeMessage<ImageChunk>(nullptr);
  }

  ImageChunk* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ImageChunk>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ImageChunk& from);
  void MergeFrom(const ImageChunk& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImageChunk* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "filestream.ImageChunk";
  }
  protected:
  explicit ImageChunk(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_FileStream_2eproto);
    return ::descriptor_table_FileStream_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFrameChunkFieldNumber = 2,
    kChunkIdFieldNumber = 1,
  };
  // bytes frameChunk = 2;
  void clear_framechunk();
  const std::string& framechunk() const;
  void set_framechunk(const std::string& value);
  void set_framechunk(std::string&& value);
  void set_framechunk(const char* value);
  void set_framechunk(const void* value, size_t size);
  std::string* mutable_framechunk();
  std::string* release_framechunk();
  void set_allocated_framechunk(std::string* framechunk);
  private:
  const std::string& _internal_framechunk() const;
  void _internal_set_framechunk(const std::string& value);
  std::string* _internal_mutable_framechunk();
  public:

  // uint32 chunkId = 1;
  void clear_chunkid();
  ::PROTOBUF_NAMESPACE_ID::uint32 chunkid() const;
  void set_chunkid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_chunkid() const;
  void _internal_set_chunkid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:filestream.ImageChunk)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr framechunk_;
  ::PROTOBUF_NAMESPACE_ID::uint32 chunkid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_FileStream_2eproto;
};
// -------------------------------------------------------------------

class EpochTimestamp PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:filestream.EpochTimestamp) */ {
 public:
  inline EpochTimestamp() : EpochTimestamp(nullptr) {}
  virtual ~EpochTimestamp();

  EpochTimestamp(const EpochTimestamp& from);
  EpochTimestamp(EpochTimestamp&& from) noexcept
    : EpochTimestamp() {
    *this = ::std::move(from);
  }

  inline EpochTimestamp& operator=(const EpochTimestamp& from) {
    CopyFrom(from);
    return *this;
  }
  inline EpochTimestamp& operator=(EpochTimestamp&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EpochTimestamp& default_instance();

  static inline const EpochTimestamp* internal_default_instance() {
    return reinterpret_cast<const EpochTimestamp*>(
               &_EpochTimestamp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(EpochTimestamp& a, EpochTimestamp& b) {
    a.Swap(&b);
  }
  inline void Swap(EpochTimestamp* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EpochTimestamp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EpochTimestamp* New() const final {
    return CreateMaybeMessage<EpochTimestamp>(nullptr);
  }

  EpochTimestamp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EpochTimestamp>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EpochTimestamp& from);
  void MergeFrom(const EpochTimestamp& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EpochTimestamp* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "filestream.EpochTimestamp";
  }
  protected:
  explicit EpochTimestamp(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_FileStream_2eproto);
    return ::descriptor_table_FileStream_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecondsFieldNumber = 1,
    kMillisecondsFieldNumber = 2,
    kMicrosecondsFieldNumber = 3,
  };
  // uint64 seconds = 1;
  void clear_seconds();
  ::PROTOBUF_NAMESPACE_ID::uint64 seconds() const;
  void set_seconds(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_seconds() const;
  void _internal_set_seconds(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // double milliseconds = 2;
  void clear_milliseconds();
  double milliseconds() const;
  void set_milliseconds(double value);
  private:
  double _internal_milliseconds() const;
  void _internal_set_milliseconds(double value);
  public:

  // double microseconds = 3;
  void clear_microseconds();
  double microseconds() const;
  void set_microseconds(double value);
  private:
  double _internal_microseconds() const;
  void _internal_set_microseconds(double value);
  public:

  // @@protoc_insertion_point(class_scope:filestream.EpochTimestamp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 seconds_;
  double milliseconds_;
  double microseconds_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_FileStream_2eproto;
};
// -------------------------------------------------------------------

class CameraId PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:filestream.CameraId) */ {
 public:
  inline CameraId() : CameraId(nullptr) {}
  virtual ~CameraId();

  CameraId(const CameraId& from);
  CameraId(CameraId&& from) noexcept
    : CameraId() {
    *this = ::std::move(from);
  }

  inline CameraId& operator=(const CameraId& from) {
    CopyFrom(from);
    return *this;
  }
  inline CameraId& operator=(CameraId&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CameraId& default_instance();

  static inline const CameraId* internal_default_instance() {
    return reinterpret_cast<const CameraId*>(
               &_CameraId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CameraId& a, CameraId& b) {
    a.Swap(&b);
  }
  inline void Swap(CameraId* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CameraId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CameraId* New() const final {
    return CreateMaybeMessage<CameraId>(nullptr);
  }

  CameraId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CameraId>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CameraId& from);
  void MergeFrom(const CameraId& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CameraId* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "filestream.CameraId";
  }
  protected:
  explicit CameraId(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_FileStream_2eproto);
    return ::descriptor_table_FileStream_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCameraIdFieldNumber = 1,
    kLensIdFieldNumber = 2,
  };
  // string cameraId = 1;
  void clear_cameraid();
  const std::string& cameraid() const;
  void set_cameraid(const std::string& value);
  void set_cameraid(std::string&& value);
  void set_cameraid(const char* value);
  void set_cameraid(const char* value, size_t size);
  std::string* mutable_cameraid();
  std::string* release_cameraid();
  void set_allocated_cameraid(std::string* cameraid);
  private:
  const std::string& _internal_cameraid() const;
  void _internal_set_cameraid(const std::string& value);
  std::string* _internal_mutable_cameraid();
  public:

  // string lensId = 2;
  void clear_lensid();
  const std::string& lensid() const;
  void set_lensid(const std::string& value);
  void set_lensid(std::string&& value);
  void set_lensid(const char* value);
  void set_lensid(const char* value, size_t size);
  std::string* mutable_lensid();
  std::string* release_lensid();
  void set_allocated_lensid(std::string* lensid);
  private:
  const std::string& _internal_lensid() const;
  void _internal_set_lensid(const std::string& value);
  std::string* _internal_mutable_lensid();
  public:

  // @@protoc_insertion_point(class_scope:filestream.CameraId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cameraid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr lensid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_FileStream_2eproto;
};
// -------------------------------------------------------------------

class HealthCheckRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:filestream.HealthCheckRequest) */ {
 public:
  inline HealthCheckRequest() : HealthCheckRequest(nullptr) {}
  virtual ~HealthCheckRequest();

  HealthCheckRequest(const HealthCheckRequest& from);
  HealthCheckRequest(HealthCheckRequest&& from) noexcept
    : HealthCheckRequest() {
    *this = ::std::move(from);
  }

  inline HealthCheckRequest& operator=(const HealthCheckRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HealthCheckRequest& operator=(HealthCheckRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HealthCheckRequest& default_instance();

  static inline const HealthCheckRequest* internal_default_instance() {
    return reinterpret_cast<const HealthCheckRequest*>(
               &_HealthCheckRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(HealthCheckRequest& a, HealthCheckRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HealthCheckRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HealthCheckRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HealthCheckRequest* New() const final {
    return CreateMaybeMessage<HealthCheckRequest>(nullptr);
  }

  HealthCheckRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HealthCheckRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HealthCheckRequest& from);
  void MergeFrom(const HealthCheckRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HealthCheckRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "filestream.HealthCheckRequest";
  }
  protected:
  explicit HealthCheckRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_FileStream_2eproto);
    return ::descriptor_table_FileStream_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceFieldNumber = 1,
  };
  // string service = 1;
  void clear_service();
  const std::string& service() const;
  void set_service(const std::string& value);
  void set_service(std::string&& value);
  void set_service(const char* value);
  void set_service(const char* value, size_t size);
  std::string* mutable_service();
  std::string* release_service();
  void set_allocated_service(std::string* service);
  private:
  const std::string& _internal_service() const;
  void _internal_set_service(const std::string& value);
  std::string* _internal_mutable_service();
  public:

  // @@protoc_insertion_point(class_scope:filestream.HealthCheckRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_FileStream_2eproto;
};
// -------------------------------------------------------------------

class HealthCheckResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:filestream.HealthCheckResponse) */ {
 public:
  inline HealthCheckResponse() : HealthCheckResponse(nullptr) {}
  virtual ~HealthCheckResponse();

  HealthCheckResponse(const HealthCheckResponse& from);
  HealthCheckResponse(HealthCheckResponse&& from) noexcept
    : HealthCheckResponse() {
    *this = ::std::move(from);
  }

  inline HealthCheckResponse& operator=(const HealthCheckResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline HealthCheckResponse& operator=(HealthCheckResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HealthCheckResponse& default_instance();

  static inline const HealthCheckResponse* internal_default_instance() {
    return reinterpret_cast<const HealthCheckResponse*>(
               &_HealthCheckResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(HealthCheckResponse& a, HealthCheckResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(HealthCheckResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HealthCheckResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HealthCheckResponse* New() const final {
    return CreateMaybeMessage<HealthCheckResponse>(nullptr);
  }

  HealthCheckResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HealthCheckResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HealthCheckResponse& from);
  void MergeFrom(const HealthCheckResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HealthCheckResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "filestream.HealthCheckResponse";
  }
  protected:
  explicit HealthCheckResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_FileStream_2eproto);
    return ::descriptor_table_FileStream_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef HealthCheckResponse_ServingStatus ServingStatus;
  static constexpr ServingStatus UNKNOWN =
    HealthCheckResponse_ServingStatus_UNKNOWN;
  static constexpr ServingStatus SERVING =
    HealthCheckResponse_ServingStatus_SERVING;
  static constexpr ServingStatus NOT_SERVING =
    HealthCheckResponse_ServingStatus_NOT_SERVING;
  static constexpr ServingStatus SERVICE_UNKNOWN =
    HealthCheckResponse_ServingStatus_SERVICE_UNKNOWN;
  static inline bool ServingStatus_IsValid(int value) {
    return HealthCheckResponse_ServingStatus_IsValid(value);
  }
  static constexpr ServingStatus ServingStatus_MIN =
    HealthCheckResponse_ServingStatus_ServingStatus_MIN;
  static constexpr ServingStatus ServingStatus_MAX =
    HealthCheckResponse_ServingStatus_ServingStatus_MAX;
  static constexpr int ServingStatus_ARRAYSIZE =
    HealthCheckResponse_ServingStatus_ServingStatus_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ServingStatus_descriptor() {
    return HealthCheckResponse_ServingStatus_descriptor();
  }
  template<typename T>
  static inline const std::string& ServingStatus_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ServingStatus>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ServingStatus_Name.");
    return HealthCheckResponse_ServingStatus_Name(enum_t_value);
  }
  static inline bool ServingStatus_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ServingStatus* value) {
    return HealthCheckResponse_ServingStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // .filestream.HealthCheckResponse.ServingStatus status = 1;
  void clear_status();
  ::filestream::HealthCheckResponse_ServingStatus status() const;
  void set_status(::filestream::HealthCheckResponse_ServingStatus value);
  private:
  ::filestream::HealthCheckResponse_ServingStatus _internal_status() const;
  void _internal_set_status(::filestream::HealthCheckResponse_ServingStatus value);
  public:

  // @@protoc_insertion_point(class_scope:filestream.HealthCheckResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_FileStream_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Image

// .filestream.FrameMeta frameMeta = 1;
inline bool Image::_internal_has_framemeta() const {
  return this != internal_default_instance() && framemeta_ != nullptr;
}
inline bool Image::has_framemeta() const {
  return _internal_has_framemeta();
}
inline void Image::clear_framemeta() {
  if (GetArena() == nullptr && framemeta_ != nullptr) {
    delete framemeta_;
  }
  framemeta_ = nullptr;
}
inline const ::filestream::FrameMeta& Image::_internal_framemeta() const {
  const ::filestream::FrameMeta* p = framemeta_;
  return p != nullptr ? *p : reinterpret_cast<const ::filestream::FrameMeta&>(
      ::filestream::_FrameMeta_default_instance_);
}
inline const ::filestream::FrameMeta& Image::framemeta() const {
  // @@protoc_insertion_point(field_get:filestream.Image.frameMeta)
  return _internal_framemeta();
}
inline void Image::unsafe_arena_set_allocated_framemeta(
    ::filestream::FrameMeta* framemeta) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(framemeta_);
  }
  framemeta_ = framemeta;
  if (framemeta) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:filestream.Image.frameMeta)
}
inline ::filestream::FrameMeta* Image::release_framemeta() {
  
  ::filestream::FrameMeta* temp = framemeta_;
  framemeta_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::filestream::FrameMeta* Image::unsafe_arena_release_framemeta() {
  // @@protoc_insertion_point(field_release:filestream.Image.frameMeta)
  
  ::filestream::FrameMeta* temp = framemeta_;
  framemeta_ = nullptr;
  return temp;
}
inline ::filestream::FrameMeta* Image::_internal_mutable_framemeta() {
  
  if (framemeta_ == nullptr) {
    auto* p = CreateMaybeMessage<::filestream::FrameMeta>(GetArena());
    framemeta_ = p;
  }
  return framemeta_;
}
inline ::filestream::FrameMeta* Image::mutable_framemeta() {
  // @@protoc_insertion_point(field_mutable:filestream.Image.frameMeta)
  return _internal_mutable_framemeta();
}
inline void Image::set_allocated_framemeta(::filestream::FrameMeta* framemeta) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete framemeta_;
  }
  if (framemeta) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(framemeta);
    if (message_arena != submessage_arena) {
      framemeta = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, framemeta, submessage_arena);
    }
    
  } else {
    
  }
  framemeta_ = framemeta;
  // @@protoc_insertion_point(field_set_allocated:filestream.Image.frameMeta)
}

// .filestream.ImageChunk imageChunk = 2;
inline bool Image::_internal_has_imagechunk() const {
  return this != internal_default_instance() && imagechunk_ != nullptr;
}
inline bool Image::has_imagechunk() const {
  return _internal_has_imagechunk();
}
inline void Image::clear_imagechunk() {
  if (GetArena() == nullptr && imagechunk_ != nullptr) {
    delete imagechunk_;
  }
  imagechunk_ = nullptr;
}
inline const ::filestream::ImageChunk& Image::_internal_imagechunk() const {
  const ::filestream::ImageChunk* p = imagechunk_;
  return p != nullptr ? *p : reinterpret_cast<const ::filestream::ImageChunk&>(
      ::filestream::_ImageChunk_default_instance_);
}
inline const ::filestream::ImageChunk& Image::imagechunk() const {
  // @@protoc_insertion_point(field_get:filestream.Image.imageChunk)
  return _internal_imagechunk();
}
inline void Image::unsafe_arena_set_allocated_imagechunk(
    ::filestream::ImageChunk* imagechunk) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(imagechunk_);
  }
  imagechunk_ = imagechunk;
  if (imagechunk) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:filestream.Image.imageChunk)
}
inline ::filestream::ImageChunk* Image::release_imagechunk() {
  
  ::filestream::ImageChunk* temp = imagechunk_;
  imagechunk_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::filestream::ImageChunk* Image::unsafe_arena_release_imagechunk() {
  // @@protoc_insertion_point(field_release:filestream.Image.imageChunk)
  
  ::filestream::ImageChunk* temp = imagechunk_;
  imagechunk_ = nullptr;
  return temp;
}
inline ::filestream::ImageChunk* Image::_internal_mutable_imagechunk() {
  
  if (imagechunk_ == nullptr) {
    auto* p = CreateMaybeMessage<::filestream::ImageChunk>(GetArena());
    imagechunk_ = p;
  }
  return imagechunk_;
}
inline ::filestream::ImageChunk* Image::mutable_imagechunk() {
  // @@protoc_insertion_point(field_mutable:filestream.Image.imageChunk)
  return _internal_mutable_imagechunk();
}
inline void Image::set_allocated_imagechunk(::filestream::ImageChunk* imagechunk) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete imagechunk_;
  }
  if (imagechunk) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(imagechunk);
    if (message_arena != submessage_arena) {
      imagechunk = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, imagechunk, submessage_arena);
    }
    
  } else {
    
  }
  imagechunk_ = imagechunk;
  // @@protoc_insertion_point(field_set_allocated:filestream.Image.imageChunk)
}

// -------------------------------------------------------------------

// ImageHash

// string fileHash = 1;
inline void ImageHash::clear_filehash() {
  filehash_.ClearToEmpty();
}
inline const std::string& ImageHash::filehash() const {
  // @@protoc_insertion_point(field_get:filestream.ImageHash.fileHash)
  return _internal_filehash();
}
inline void ImageHash::set_filehash(const std::string& value) {
  _internal_set_filehash(value);
  // @@protoc_insertion_point(field_set:filestream.ImageHash.fileHash)
}
inline std::string* ImageHash::mutable_filehash() {
  // @@protoc_insertion_point(field_mutable:filestream.ImageHash.fileHash)
  return _internal_mutable_filehash();
}
inline const std::string& ImageHash::_internal_filehash() const {
  return filehash_.Get();
}
inline void ImageHash::_internal_set_filehash(const std::string& value) {
  
  filehash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ImageHash::set_filehash(std::string&& value) {
  
  filehash_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:filestream.ImageHash.fileHash)
}
inline void ImageHash::set_filehash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  filehash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:filestream.ImageHash.fileHash)
}
inline void ImageHash::set_filehash(const char* value,
    size_t size) {
  
  filehash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:filestream.ImageHash.fileHash)
}
inline std::string* ImageHash::_internal_mutable_filehash() {
  
  return filehash_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ImageHash::release_filehash() {
  // @@protoc_insertion_point(field_release:filestream.ImageHash.fileHash)
  return filehash_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ImageHash::set_allocated_filehash(std::string* filehash) {
  if (filehash != nullptr) {
    
  } else {
    
  }
  filehash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), filehash,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:filestream.ImageHash.fileHash)
}

// .filestream.HashAlgorithm hashAlgorithm = 2;
inline void ImageHash::clear_hashalgorithm() {
  hashalgorithm_ = 0;
}
inline ::filestream::HashAlgorithm ImageHash::_internal_hashalgorithm() const {
  return static_cast< ::filestream::HashAlgorithm >(hashalgorithm_);
}
inline ::filestream::HashAlgorithm ImageHash::hashalgorithm() const {
  // @@protoc_insertion_point(field_get:filestream.ImageHash.hashAlgorithm)
  return _internal_hashalgorithm();
}
inline void ImageHash::_internal_set_hashalgorithm(::filestream::HashAlgorithm value) {
  
  hashalgorithm_ = value;
}
inline void ImageHash::set_hashalgorithm(::filestream::HashAlgorithm value) {
  _internal_set_hashalgorithm(value);
  // @@protoc_insertion_point(field_set:filestream.ImageHash.hashAlgorithm)
}

// -------------------------------------------------------------------

// FrameMeta

// uint32 frameIndex = 1;
inline void FrameMeta::clear_frameindex() {
  frameindex_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FrameMeta::_internal_frameindex() const {
  return frameindex_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FrameMeta::frameindex() const {
  // @@protoc_insertion_point(field_get:filestream.FrameMeta.frameIndex)
  return _internal_frameindex();
}
inline void FrameMeta::_internal_set_frameindex(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  frameindex_ = value;
}
inline void FrameMeta::set_frameindex(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_frameindex(value);
  // @@protoc_insertion_point(field_set:filestream.FrameMeta.frameIndex)
}

// .filestream.EpochTimestamp epochTimestamp = 2;
inline bool FrameMeta::_internal_has_epochtimestamp() const {
  return timestamp_case() == kEpochTimestamp;
}
inline bool FrameMeta::has_epochtimestamp() const {
  return _internal_has_epochtimestamp();
}
inline void FrameMeta::set_has_epochtimestamp() {
  _oneof_case_[0] = kEpochTimestamp;
}
inline void FrameMeta::clear_epochtimestamp() {
  if (_internal_has_epochtimestamp()) {
    if (GetArena() == nullptr) {
      delete timestamp_.epochtimestamp_;
    }
    clear_has_timestamp();
  }
}
inline ::filestream::EpochTimestamp* FrameMeta::release_epochtimestamp() {
  // @@protoc_insertion_point(field_release:filestream.FrameMeta.epochTimestamp)
  if (_internal_has_epochtimestamp()) {
    clear_has_timestamp();
      ::filestream::EpochTimestamp* temp = timestamp_.epochtimestamp_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    timestamp_.epochtimestamp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::filestream::EpochTimestamp& FrameMeta::_internal_epochtimestamp() const {
  return _internal_has_epochtimestamp()
      ? *timestamp_.epochtimestamp_
      : reinterpret_cast< ::filestream::EpochTimestamp&>(::filestream::_EpochTimestamp_default_instance_);
}
inline const ::filestream::EpochTimestamp& FrameMeta::epochtimestamp() const {
  // @@protoc_insertion_point(field_get:filestream.FrameMeta.epochTimestamp)
  return _internal_epochtimestamp();
}
inline ::filestream::EpochTimestamp* FrameMeta::unsafe_arena_release_epochtimestamp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:filestream.FrameMeta.epochTimestamp)
  if (_internal_has_epochtimestamp()) {
    clear_has_timestamp();
    ::filestream::EpochTimestamp* temp = timestamp_.epochtimestamp_;
    timestamp_.epochtimestamp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FrameMeta::unsafe_arena_set_allocated_epochtimestamp(::filestream::EpochTimestamp* epochtimestamp) {
  clear_timestamp();
  if (epochtimestamp) {
    set_has_epochtimestamp();
    timestamp_.epochtimestamp_ = epochtimestamp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:filestream.FrameMeta.epochTimestamp)
}
inline ::filestream::EpochTimestamp* FrameMeta::_internal_mutable_epochtimestamp() {
  if (!_internal_has_epochtimestamp()) {
    clear_timestamp();
    set_has_epochtimestamp();
    timestamp_.epochtimestamp_ = CreateMaybeMessage< ::filestream::EpochTimestamp >(GetArena());
  }
  return timestamp_.epochtimestamp_;
}
inline ::filestream::EpochTimestamp* FrameMeta::mutable_epochtimestamp() {
  // @@protoc_insertion_point(field_mutable:filestream.FrameMeta.epochTimestamp)
  return _internal_mutable_epochtimestamp();
}

// .google.protobuf.Timestamp protoTimestamp = 3;
inline bool FrameMeta::_internal_has_prototimestamp() const {
  return timestamp_case() == kProtoTimestamp;
}
inline bool FrameMeta::has_prototimestamp() const {
  return _internal_has_prototimestamp();
}
inline void FrameMeta::set_has_prototimestamp() {
  _oneof_case_[0] = kProtoTimestamp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* FrameMeta::release_prototimestamp() {
  // @@protoc_insertion_point(field_release:filestream.FrameMeta.protoTimestamp)
  if (_internal_has_prototimestamp()) {
    clear_has_timestamp();
      PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_.prototimestamp_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    timestamp_.prototimestamp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& FrameMeta::_internal_prototimestamp() const {
  return _internal_has_prototimestamp()
      ? *timestamp_.prototimestamp_
      : reinterpret_cast< PROTOBUF_NAMESPACE_ID::Timestamp&>(PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& FrameMeta::prototimestamp() const {
  // @@protoc_insertion_point(field_get:filestream.FrameMeta.protoTimestamp)
  return _internal_prototimestamp();
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* FrameMeta::unsafe_arena_release_prototimestamp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:filestream.FrameMeta.protoTimestamp)
  if (_internal_has_prototimestamp()) {
    clear_has_timestamp();
    PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_.prototimestamp_;
    timestamp_.prototimestamp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FrameMeta::unsafe_arena_set_allocated_prototimestamp(PROTOBUF_NAMESPACE_ID::Timestamp* prototimestamp) {
  clear_timestamp();
  if (prototimestamp) {
    set_has_prototimestamp();
    timestamp_.prototimestamp_ = prototimestamp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:filestream.FrameMeta.protoTimestamp)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* FrameMeta::_internal_mutable_prototimestamp() {
  if (!_internal_has_prototimestamp()) {
    clear_timestamp();
    set_has_prototimestamp();
    timestamp_.prototimestamp_ = CreateMaybeMessage< PROTOBUF_NAMESPACE_ID::Timestamp >(GetArena());
  }
  return timestamp_.prototimestamp_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* FrameMeta::mutable_prototimestamp() {
  // @@protoc_insertion_point(field_mutable:filestream.FrameMeta.protoTimestamp)
  return _internal_mutable_prototimestamp();
}

// .filestream.ImageHash imageHash = 4;
inline bool FrameMeta::_internal_has_imagehash() const {
  return this != internal_default_instance() && imagehash_ != nullptr;
}
inline bool FrameMeta::has_imagehash() const {
  return _internal_has_imagehash();
}
inline void FrameMeta::clear_imagehash() {
  if (GetArena() == nullptr && imagehash_ != nullptr) {
    delete imagehash_;
  }
  imagehash_ = nullptr;
}
inline const ::filestream::ImageHash& FrameMeta::_internal_imagehash() const {
  const ::filestream::ImageHash* p = imagehash_;
  return p != nullptr ? *p : reinterpret_cast<const ::filestream::ImageHash&>(
      ::filestream::_ImageHash_default_instance_);
}
inline const ::filestream::ImageHash& FrameMeta::imagehash() const {
  // @@protoc_insertion_point(field_get:filestream.FrameMeta.imageHash)
  return _internal_imagehash();
}
inline void FrameMeta::unsafe_arena_set_allocated_imagehash(
    ::filestream::ImageHash* imagehash) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(imagehash_);
  }
  imagehash_ = imagehash;
  if (imagehash) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:filestream.FrameMeta.imageHash)
}
inline ::filestream::ImageHash* FrameMeta::release_imagehash() {
  
  ::filestream::ImageHash* temp = imagehash_;
  imagehash_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::filestream::ImageHash* FrameMeta::unsafe_arena_release_imagehash() {
  // @@protoc_insertion_point(field_release:filestream.FrameMeta.imageHash)
  
  ::filestream::ImageHash* temp = imagehash_;
  imagehash_ = nullptr;
  return temp;
}
inline ::filestream::ImageHash* FrameMeta::_internal_mutable_imagehash() {
  
  if (imagehash_ == nullptr) {
    auto* p = CreateMaybeMessage<::filestream::ImageHash>(GetArena());
    imagehash_ = p;
  }
  return imagehash_;
}
inline ::filestream::ImageHash* FrameMeta::mutable_imagehash() {
  // @@protoc_insertion_point(field_mutable:filestream.FrameMeta.imageHash)
  return _internal_mutable_imagehash();
}
inline void FrameMeta::set_allocated_imagehash(::filestream::ImageHash* imagehash) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete imagehash_;
  }
  if (imagehash) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(imagehash);
    if (message_arena != submessage_arena) {
      imagehash = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, imagehash, submessage_arena);
    }
    
  } else {
    
  }
  imagehash_ = imagehash;
  // @@protoc_insertion_point(field_set_allocated:filestream.FrameMeta.imageHash)
}

// .filestream.MaxSize frameSize = 5;
inline bool FrameMeta::_internal_has_framesize() const {
  return this != internal_default_instance() && framesize_ != nullptr;
}
inline bool FrameMeta::has_framesize() const {
  return _internal_has_framesize();
}
inline void FrameMeta::clear_framesize() {
  if (GetArena() == nullptr && framesize_ != nullptr) {
    delete framesize_;
  }
  framesize_ = nullptr;
}
inline const ::filestream::MaxSize& FrameMeta::_internal_framesize() const {
  const ::filestream::MaxSize* p = framesize_;
  return p != nullptr ? *p : reinterpret_cast<const ::filestream::MaxSize&>(
      ::filestream::_MaxSize_default_instance_);
}
inline const ::filestream::MaxSize& FrameMeta::framesize() const {
  // @@protoc_insertion_point(field_get:filestream.FrameMeta.frameSize)
  return _internal_framesize();
}
inline void FrameMeta::unsafe_arena_set_allocated_framesize(
    ::filestream::MaxSize* framesize) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(framesize_);
  }
  framesize_ = framesize;
  if (framesize) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:filestream.FrameMeta.frameSize)
}
inline ::filestream::MaxSize* FrameMeta::release_framesize() {
  
  ::filestream::MaxSize* temp = framesize_;
  framesize_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::filestream::MaxSize* FrameMeta::unsafe_arena_release_framesize() {
  // @@protoc_insertion_point(field_release:filestream.FrameMeta.frameSize)
  
  ::filestream::MaxSize* temp = framesize_;
  framesize_ = nullptr;
  return temp;
}
inline ::filestream::MaxSize* FrameMeta::_internal_mutable_framesize() {
  
  if (framesize_ == nullptr) {
    auto* p = CreateMaybeMessage<::filestream::MaxSize>(GetArena());
    framesize_ = p;
  }
  return framesize_;
}
inline ::filestream::MaxSize* FrameMeta::mutable_framesize() {
  // @@protoc_insertion_point(field_mutable:filestream.FrameMeta.frameSize)
  return _internal_mutable_framesize();
}
inline void FrameMeta::set_allocated_framesize(::filestream::MaxSize* framesize) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete framesize_;
  }
  if (framesize) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(framesize);
    if (message_arena != submessage_arena) {
      framesize = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, framesize, submessage_arena);
    }
    
  } else {
    
  }
  framesize_ = framesize;
  // @@protoc_insertion_point(field_set_allocated:filestream.FrameMeta.frameSize)
}

// uint32 xAxisPixels = 9;
inline void FrameMeta::clear_xaxispixels() {
  xaxispixels_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FrameMeta::_internal_xaxispixels() const {
  return xaxispixels_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FrameMeta::xaxispixels() const {
  // @@protoc_insertion_point(field_get:filestream.FrameMeta.xAxisPixels)
  return _internal_xaxispixels();
}
inline void FrameMeta::_internal_set_xaxispixels(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  xaxispixels_ = value;
}
inline void FrameMeta::set_xaxispixels(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_xaxispixels(value);
  // @@protoc_insertion_point(field_set:filestream.FrameMeta.xAxisPixels)
}

// uint32 yAxisPixels = 10;
inline void FrameMeta::clear_yaxispixels() {
  yaxispixels_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FrameMeta::_internal_yaxispixels() const {
  return yaxispixels_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FrameMeta::yaxispixels() const {
  // @@protoc_insertion_point(field_get:filestream.FrameMeta.yAxisPixels)
  return _internal_yaxispixels();
}
inline void FrameMeta::_internal_set_yaxispixels(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  yaxispixels_ = value;
}
inline void FrameMeta::set_yaxispixels(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_yaxispixels(value);
  // @@protoc_insertion_point(field_set:filestream.FrameMeta.yAxisPixels)
}

// uint32 imageBitDepth = 11;
inline void FrameMeta::clear_imagebitdepth() {
  imagebitdepth_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FrameMeta::_internal_imagebitdepth() const {
  return imagebitdepth_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FrameMeta::imagebitdepth() const {
  // @@protoc_insertion_point(field_get:filestream.FrameMeta.imageBitDepth)
  return _internal_imagebitdepth();
}
inline void FrameMeta::_internal_set_imagebitdepth(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  imagebitdepth_ = value;
}
inline void FrameMeta::set_imagebitdepth(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_imagebitdepth(value);
  // @@protoc_insertion_point(field_set:filestream.FrameMeta.imageBitDepth)
}

// uint32 imageBitDepthReal = 12;
inline void FrameMeta::clear_imagebitdepthreal() {
  imagebitdepthreal_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FrameMeta::_internal_imagebitdepthreal() const {
  return imagebitdepthreal_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FrameMeta::imagebitdepthreal() const {
  // @@protoc_insertion_point(field_get:filestream.FrameMeta.imageBitDepthReal)
  return _internal_imagebitdepthreal();
}
inline void FrameMeta::_internal_set_imagebitdepthreal(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  imagebitdepthreal_ = value;
}
inline void FrameMeta::set_imagebitdepthreal(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_imagebitdepthreal(value);
  // @@protoc_insertion_point(field_set:filestream.FrameMeta.imageBitDepthReal)
}

// .filestream.CameraId cameraId = 13;
inline bool FrameMeta::_internal_has_cameraid() const {
  return this != internal_default_instance() && cameraid_ != nullptr;
}
inline bool FrameMeta::has_cameraid() const {
  return _internal_has_cameraid();
}
inline void FrameMeta::clear_cameraid() {
  if (GetArena() == nullptr && cameraid_ != nullptr) {
    delete cameraid_;
  }
  cameraid_ = nullptr;
}
inline const ::filestream::CameraId& FrameMeta::_internal_cameraid() const {
  const ::filestream::CameraId* p = cameraid_;
  return p != nullptr ? *p : reinterpret_cast<const ::filestream::CameraId&>(
      ::filestream::_CameraId_default_instance_);
}
inline const ::filestream::CameraId& FrameMeta::cameraid() const {
  // @@protoc_insertion_point(field_get:filestream.FrameMeta.cameraId)
  return _internal_cameraid();
}
inline void FrameMeta::unsafe_arena_set_allocated_cameraid(
    ::filestream::CameraId* cameraid) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cameraid_);
  }
  cameraid_ = cameraid;
  if (cameraid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:filestream.FrameMeta.cameraId)
}
inline ::filestream::CameraId* FrameMeta::release_cameraid() {
  
  ::filestream::CameraId* temp = cameraid_;
  cameraid_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::filestream::CameraId* FrameMeta::unsafe_arena_release_cameraid() {
  // @@protoc_insertion_point(field_release:filestream.FrameMeta.cameraId)
  
  ::filestream::CameraId* temp = cameraid_;
  cameraid_ = nullptr;
  return temp;
}
inline ::filestream::CameraId* FrameMeta::_internal_mutable_cameraid() {
  
  if (cameraid_ == nullptr) {
    auto* p = CreateMaybeMessage<::filestream::CameraId>(GetArena());
    cameraid_ = p;
  }
  return cameraid_;
}
inline ::filestream::CameraId* FrameMeta::mutable_cameraid() {
  // @@protoc_insertion_point(field_mutable:filestream.FrameMeta.cameraId)
  return _internal_mutable_cameraid();
}
inline void FrameMeta::set_allocated_cameraid(::filestream::CameraId* cameraid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete cameraid_;
  }
  if (cameraid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(cameraid);
    if (message_arena != submessage_arena) {
      cameraid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cameraid, submessage_arena);
    }
    
  } else {
    
  }
  cameraid_ = cameraid;
  // @@protoc_insertion_point(field_set_allocated:filestream.FrameMeta.cameraId)
}

// string containerName = 6;
inline void FrameMeta::clear_containername() {
  containername_.ClearToEmpty();
}
inline const std::string& FrameMeta::containername() const {
  // @@protoc_insertion_point(field_get:filestream.FrameMeta.containerName)
  return _internal_containername();
}
inline void FrameMeta::set_containername(const std::string& value) {
  _internal_set_containername(value);
  // @@protoc_insertion_point(field_set:filestream.FrameMeta.containerName)
}
inline std::string* FrameMeta::mutable_containername() {
  // @@protoc_insertion_point(field_mutable:filestream.FrameMeta.containerName)
  return _internal_mutable_containername();
}
inline const std::string& FrameMeta::_internal_containername() const {
  return containername_.Get();
}
inline void FrameMeta::_internal_set_containername(const std::string& value) {
  
  containername_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void FrameMeta::set_containername(std::string&& value) {
  
  containername_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:filestream.FrameMeta.containerName)
}
inline void FrameMeta::set_containername(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  containername_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:filestream.FrameMeta.containerName)
}
inline void FrameMeta::set_containername(const char* value,
    size_t size) {
  
  containername_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:filestream.FrameMeta.containerName)
}
inline std::string* FrameMeta::_internal_mutable_containername() {
  
  return containername_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* FrameMeta::release_containername() {
  // @@protoc_insertion_point(field_release:filestream.FrameMeta.containerName)
  return containername_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void FrameMeta::set_allocated_containername(std::string* containername) {
  if (containername != nullptr) {
    
  } else {
    
  }
  containername_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), containername,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:filestream.FrameMeta.containerName)
}

// string xmpMeta = 7;
inline void FrameMeta::clear_xmpmeta() {
  xmpmeta_.ClearToEmpty();
}
inline const std::string& FrameMeta::xmpmeta() const {
  // @@protoc_insertion_point(field_get:filestream.FrameMeta.xmpMeta)
  return _internal_xmpmeta();
}
inline void FrameMeta::set_xmpmeta(const std::string& value) {
  _internal_set_xmpmeta(value);
  // @@protoc_insertion_point(field_set:filestream.FrameMeta.xmpMeta)
}
inline std::string* FrameMeta::mutable_xmpmeta() {
  // @@protoc_insertion_point(field_mutable:filestream.FrameMeta.xmpMeta)
  return _internal_mutable_xmpmeta();
}
inline const std::string& FrameMeta::_internal_xmpmeta() const {
  return xmpmeta_.Get();
}
inline void FrameMeta::_internal_set_xmpmeta(const std::string& value) {
  
  xmpmeta_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void FrameMeta::set_xmpmeta(std::string&& value) {
  
  xmpmeta_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:filestream.FrameMeta.xmpMeta)
}
inline void FrameMeta::set_xmpmeta(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  xmpmeta_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:filestream.FrameMeta.xmpMeta)
}
inline void FrameMeta::set_xmpmeta(const char* value,
    size_t size) {
  
  xmpmeta_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:filestream.FrameMeta.xmpMeta)
}
inline std::string* FrameMeta::_internal_mutable_xmpmeta() {
  
  return xmpmeta_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* FrameMeta::release_xmpmeta() {
  // @@protoc_insertion_point(field_release:filestream.FrameMeta.xmpMeta)
  return xmpmeta_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void FrameMeta::set_allocated_xmpmeta(std::string* xmpmeta) {
  if (xmpmeta != nullptr) {
    
  } else {
    
  }
  xmpmeta_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), xmpmeta,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:filestream.FrameMeta.xmpMeta)
}

// string exifMeta = 8;
inline void FrameMeta::clear_exifmeta() {
  exifmeta_.ClearToEmpty();
}
inline const std::string& FrameMeta::exifmeta() const {
  // @@protoc_insertion_point(field_get:filestream.FrameMeta.exifMeta)
  return _internal_exifmeta();
}
inline void FrameMeta::set_exifmeta(const std::string& value) {
  _internal_set_exifmeta(value);
  // @@protoc_insertion_point(field_set:filestream.FrameMeta.exifMeta)
}
inline std::string* FrameMeta::mutable_exifmeta() {
  // @@protoc_insertion_point(field_mutable:filestream.FrameMeta.exifMeta)
  return _internal_mutable_exifmeta();
}
inline const std::string& FrameMeta::_internal_exifmeta() const {
  return exifmeta_.Get();
}
inline void FrameMeta::_internal_set_exifmeta(const std::string& value) {
  
  exifmeta_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void FrameMeta::set_exifmeta(std::string&& value) {
  
  exifmeta_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:filestream.FrameMeta.exifMeta)
}
inline void FrameMeta::set_exifmeta(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  exifmeta_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:filestream.FrameMeta.exifMeta)
}
inline void FrameMeta::set_exifmeta(const char* value,
    size_t size) {
  
  exifmeta_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:filestream.FrameMeta.exifMeta)
}
inline std::string* FrameMeta::_internal_mutable_exifmeta() {
  
  return exifmeta_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* FrameMeta::release_exifmeta() {
  // @@protoc_insertion_point(field_release:filestream.FrameMeta.exifMeta)
  return exifmeta_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void FrameMeta::set_allocated_exifmeta(std::string* exifmeta) {
  if (exifmeta != nullptr) {
    
  } else {
    
  }
  exifmeta_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), exifmeta,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:filestream.FrameMeta.exifMeta)
}

inline bool FrameMeta::has_timestamp() const {
  return timestamp_case() != TIMESTAMP_NOT_SET;
}
inline void FrameMeta::clear_has_timestamp() {
  _oneof_case_[0] = TIMESTAMP_NOT_SET;
}
inline FrameMeta::TimestampCase FrameMeta::timestamp_case() const {
  return FrameMeta::TimestampCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// TransferResponse

// .filestream.ImageHash imageHash = 1;
inline bool TransferResponse::_internal_has_imagehash() const {
  return this != internal_default_instance() && imagehash_ != nullptr;
}
inline bool TransferResponse::has_imagehash() const {
  return _internal_has_imagehash();
}
inline void TransferResponse::clear_imagehash() {
  if (GetArena() == nullptr && imagehash_ != nullptr) {
    delete imagehash_;
  }
  imagehash_ = nullptr;
}
inline const ::filestream::ImageHash& TransferResponse::_internal_imagehash() const {
  const ::filestream::ImageHash* p = imagehash_;
  return p != nullptr ? *p : reinterpret_cast<const ::filestream::ImageHash&>(
      ::filestream::_ImageHash_default_instance_);
}
inline const ::filestream::ImageHash& TransferResponse::imagehash() const {
  // @@protoc_insertion_point(field_get:filestream.TransferResponse.imageHash)
  return _internal_imagehash();
}
inline void TransferResponse::unsafe_arena_set_allocated_imagehash(
    ::filestream::ImageHash* imagehash) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(imagehash_);
  }
  imagehash_ = imagehash;
  if (imagehash) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:filestream.TransferResponse.imageHash)
}
inline ::filestream::ImageHash* TransferResponse::release_imagehash() {
  
  ::filestream::ImageHash* temp = imagehash_;
  imagehash_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::filestream::ImageHash* TransferResponse::unsafe_arena_release_imagehash() {
  // @@protoc_insertion_point(field_release:filestream.TransferResponse.imageHash)
  
  ::filestream::ImageHash* temp = imagehash_;
  imagehash_ = nullptr;
  return temp;
}
inline ::filestream::ImageHash* TransferResponse::_internal_mutable_imagehash() {
  
  if (imagehash_ == nullptr) {
    auto* p = CreateMaybeMessage<::filestream::ImageHash>(GetArena());
    imagehash_ = p;
  }
  return imagehash_;
}
inline ::filestream::ImageHash* TransferResponse::mutable_imagehash() {
  // @@protoc_insertion_point(field_mutable:filestream.TransferResponse.imageHash)
  return _internal_mutable_imagehash();
}
inline void TransferResponse::set_allocated_imagehash(::filestream::ImageHash* imagehash) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete imagehash_;
  }
  if (imagehash) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(imagehash);
    if (message_arena != submessage_arena) {
      imagehash = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, imagehash, submessage_arena);
    }
    
  } else {
    
  }
  imagehash_ = imagehash;
  // @@protoc_insertion_point(field_set_allocated:filestream.TransferResponse.imageHash)
}

// uint32 size = 2;
inline void TransferResponse::clear_size() {
  size_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TransferResponse::_internal_size() const {
  return size_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TransferResponse::size() const {
  // @@protoc_insertion_point(field_get:filestream.TransferResponse.size)
  return _internal_size();
}
inline void TransferResponse::_internal_set_size(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  size_ = value;
}
inline void TransferResponse::set_size(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:filestream.TransferResponse.size)
}

// -------------------------------------------------------------------

// MaxSize

// uint32 size = 1;
inline void MaxSize::clear_size() {
  size_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MaxSize::_internal_size() const {
  return size_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MaxSize::size() const {
  // @@protoc_insertion_point(field_get:filestream.MaxSize.size)
  return _internal_size();
}
inline void MaxSize::_internal_set_size(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  size_ = value;
}
inline void MaxSize::set_size(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:filestream.MaxSize.size)
}

// .filestream.SizeUnits unit = 2;
inline void MaxSize::clear_unit() {
  unit_ = 0;
}
inline ::filestream::SizeUnits MaxSize::_internal_unit() const {
  return static_cast< ::filestream::SizeUnits >(unit_);
}
inline ::filestream::SizeUnits MaxSize::unit() const {
  // @@protoc_insertion_point(field_get:filestream.MaxSize.unit)
  return _internal_unit();
}
inline void MaxSize::_internal_set_unit(::filestream::SizeUnits value) {
  
  unit_ = value;
}
inline void MaxSize::set_unit(::filestream::SizeUnits value) {
  _internal_set_unit(value);
  // @@protoc_insertion_point(field_set:filestream.MaxSize.unit)
}

// -------------------------------------------------------------------

// ImageChunk

// uint32 chunkId = 1;
inline void ImageChunk::clear_chunkid() {
  chunkid_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ImageChunk::_internal_chunkid() const {
  return chunkid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ImageChunk::chunkid() const {
  // @@protoc_insertion_point(field_get:filestream.ImageChunk.chunkId)
  return _internal_chunkid();
}
inline void ImageChunk::_internal_set_chunkid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  chunkid_ = value;
}
inline void ImageChunk::set_chunkid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_chunkid(value);
  // @@protoc_insertion_point(field_set:filestream.ImageChunk.chunkId)
}

// bytes frameChunk = 2;
inline void ImageChunk::clear_framechunk() {
  framechunk_.ClearToEmpty();
}
inline const std::string& ImageChunk::framechunk() const {
  // @@protoc_insertion_point(field_get:filestream.ImageChunk.frameChunk)
  return _internal_framechunk();
}
inline void ImageChunk::set_framechunk(const std::string& value) {
  _internal_set_framechunk(value);
  // @@protoc_insertion_point(field_set:filestream.ImageChunk.frameChunk)
}
inline std::string* ImageChunk::mutable_framechunk() {
  // @@protoc_insertion_point(field_mutable:filestream.ImageChunk.frameChunk)
  return _internal_mutable_framechunk();
}
inline const std::string& ImageChunk::_internal_framechunk() const {
  return framechunk_.Get();
}
inline void ImageChunk::_internal_set_framechunk(const std::string& value) {
  
  framechunk_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ImageChunk::set_framechunk(std::string&& value) {
  
  framechunk_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:filestream.ImageChunk.frameChunk)
}
inline void ImageChunk::set_framechunk(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  framechunk_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:filestream.ImageChunk.frameChunk)
}
inline void ImageChunk::set_framechunk(const void* value,
    size_t size) {
  
  framechunk_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:filestream.ImageChunk.frameChunk)
}
inline std::string* ImageChunk::_internal_mutable_framechunk() {
  
  return framechunk_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ImageChunk::release_framechunk() {
  // @@protoc_insertion_point(field_release:filestream.ImageChunk.frameChunk)
  return framechunk_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ImageChunk::set_allocated_framechunk(std::string* framechunk) {
  if (framechunk != nullptr) {
    
  } else {
    
  }
  framechunk_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), framechunk,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:filestream.ImageChunk.frameChunk)
}

// -------------------------------------------------------------------

// EpochTimestamp

// uint64 seconds = 1;
inline void EpochTimestamp::clear_seconds() {
  seconds_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 EpochTimestamp::_internal_seconds() const {
  return seconds_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 EpochTimestamp::seconds() const {
  // @@protoc_insertion_point(field_get:filestream.EpochTimestamp.seconds)
  return _internal_seconds();
}
inline void EpochTimestamp::_internal_set_seconds(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  seconds_ = value;
}
inline void EpochTimestamp::set_seconds(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_seconds(value);
  // @@protoc_insertion_point(field_set:filestream.EpochTimestamp.seconds)
}

// double milliseconds = 2;
inline void EpochTimestamp::clear_milliseconds() {
  milliseconds_ = 0;
}
inline double EpochTimestamp::_internal_milliseconds() const {
  return milliseconds_;
}
inline double EpochTimestamp::milliseconds() const {
  // @@protoc_insertion_point(field_get:filestream.EpochTimestamp.milliseconds)
  return _internal_milliseconds();
}
inline void EpochTimestamp::_internal_set_milliseconds(double value) {
  
  milliseconds_ = value;
}
inline void EpochTimestamp::set_milliseconds(double value) {
  _internal_set_milliseconds(value);
  // @@protoc_insertion_point(field_set:filestream.EpochTimestamp.milliseconds)
}

// double microseconds = 3;
inline void EpochTimestamp::clear_microseconds() {
  microseconds_ = 0;
}
inline double EpochTimestamp::_internal_microseconds() const {
  return microseconds_;
}
inline double EpochTimestamp::microseconds() const {
  // @@protoc_insertion_point(field_get:filestream.EpochTimestamp.microseconds)
  return _internal_microseconds();
}
inline void EpochTimestamp::_internal_set_microseconds(double value) {
  
  microseconds_ = value;
}
inline void EpochTimestamp::set_microseconds(double value) {
  _internal_set_microseconds(value);
  // @@protoc_insertion_point(field_set:filestream.EpochTimestamp.microseconds)
}

// -------------------------------------------------------------------

// CameraId

// string cameraId = 1;
inline void CameraId::clear_cameraid() {
  cameraid_.ClearToEmpty();
}
inline const std::string& CameraId::cameraid() const {
  // @@protoc_insertion_point(field_get:filestream.CameraId.cameraId)
  return _internal_cameraid();
}
inline void CameraId::set_cameraid(const std::string& value) {
  _internal_set_cameraid(value);
  // @@protoc_insertion_point(field_set:filestream.CameraId.cameraId)
}
inline std::string* CameraId::mutable_cameraid() {
  // @@protoc_insertion_point(field_mutable:filestream.CameraId.cameraId)
  return _internal_mutable_cameraid();
}
inline const std::string& CameraId::_internal_cameraid() const {
  return cameraid_.Get();
}
inline void CameraId::_internal_set_cameraid(const std::string& value) {
  
  cameraid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void CameraId::set_cameraid(std::string&& value) {
  
  cameraid_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:filestream.CameraId.cameraId)
}
inline void CameraId::set_cameraid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  cameraid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:filestream.CameraId.cameraId)
}
inline void CameraId::set_cameraid(const char* value,
    size_t size) {
  
  cameraid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:filestream.CameraId.cameraId)
}
inline std::string* CameraId::_internal_mutable_cameraid() {
  
  return cameraid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* CameraId::release_cameraid() {
  // @@protoc_insertion_point(field_release:filestream.CameraId.cameraId)
  return cameraid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CameraId::set_allocated_cameraid(std::string* cameraid) {
  if (cameraid != nullptr) {
    
  } else {
    
  }
  cameraid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cameraid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:filestream.CameraId.cameraId)
}

// string lensId = 2;
inline void CameraId::clear_lensid() {
  lensid_.ClearToEmpty();
}
inline const std::string& CameraId::lensid() const {
  // @@protoc_insertion_point(field_get:filestream.CameraId.lensId)
  return _internal_lensid();
}
inline void CameraId::set_lensid(const std::string& value) {
  _internal_set_lensid(value);
  // @@protoc_insertion_point(field_set:filestream.CameraId.lensId)
}
inline std::string* CameraId::mutable_lensid() {
  // @@protoc_insertion_point(field_mutable:filestream.CameraId.lensId)
  return _internal_mutable_lensid();
}
inline const std::string& CameraId::_internal_lensid() const {
  return lensid_.Get();
}
inline void CameraId::_internal_set_lensid(const std::string& value) {
  
  lensid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void CameraId::set_lensid(std::string&& value) {
  
  lensid_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:filestream.CameraId.lensId)
}
inline void CameraId::set_lensid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  lensid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:filestream.CameraId.lensId)
}
inline void CameraId::set_lensid(const char* value,
    size_t size) {
  
  lensid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:filestream.CameraId.lensId)
}
inline std::string* CameraId::_internal_mutable_lensid() {
  
  return lensid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* CameraId::release_lensid() {
  // @@protoc_insertion_point(field_release:filestream.CameraId.lensId)
  return lensid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CameraId::set_allocated_lensid(std::string* lensid) {
  if (lensid != nullptr) {
    
  } else {
    
  }
  lensid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), lensid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:filestream.CameraId.lensId)
}

// -------------------------------------------------------------------

// HealthCheckRequest

// string service = 1;
inline void HealthCheckRequest::clear_service() {
  service_.ClearToEmpty();
}
inline const std::string& HealthCheckRequest::service() const {
  // @@protoc_insertion_point(field_get:filestream.HealthCheckRequest.service)
  return _internal_service();
}
inline void HealthCheckRequest::set_service(const std::string& value) {
  _internal_set_service(value);
  // @@protoc_insertion_point(field_set:filestream.HealthCheckRequest.service)
}
inline std::string* HealthCheckRequest::mutable_service() {
  // @@protoc_insertion_point(field_mutable:filestream.HealthCheckRequest.service)
  return _internal_mutable_service();
}
inline const std::string& HealthCheckRequest::_internal_service() const {
  return service_.Get();
}
inline void HealthCheckRequest::_internal_set_service(const std::string& value) {
  
  service_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void HealthCheckRequest::set_service(std::string&& value) {
  
  service_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:filestream.HealthCheckRequest.service)
}
inline void HealthCheckRequest::set_service(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  service_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:filestream.HealthCheckRequest.service)
}
inline void HealthCheckRequest::set_service(const char* value,
    size_t size) {
  
  service_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:filestream.HealthCheckRequest.service)
}
inline std::string* HealthCheckRequest::_internal_mutable_service() {
  
  return service_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* HealthCheckRequest::release_service() {
  // @@protoc_insertion_point(field_release:filestream.HealthCheckRequest.service)
  return service_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void HealthCheckRequest::set_allocated_service(std::string* service) {
  if (service != nullptr) {
    
  } else {
    
  }
  service_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), service,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:filestream.HealthCheckRequest.service)
}

// -------------------------------------------------------------------

// HealthCheckResponse

// .filestream.HealthCheckResponse.ServingStatus status = 1;
inline void HealthCheckResponse::clear_status() {
  status_ = 0;
}
inline ::filestream::HealthCheckResponse_ServingStatus HealthCheckResponse::_internal_status() const {
  return static_cast< ::filestream::HealthCheckResponse_ServingStatus >(status_);
}
inline ::filestream::HealthCheckResponse_ServingStatus HealthCheckResponse::status() const {
  // @@protoc_insertion_point(field_get:filestream.HealthCheckResponse.status)
  return _internal_status();
}
inline void HealthCheckResponse::_internal_set_status(::filestream::HealthCheckResponse_ServingStatus value) {
  
  status_ = value;
}
inline void HealthCheckResponse::set_status(::filestream::HealthCheckResponse_ServingStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:filestream.HealthCheckResponse.status)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace filestream

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::filestream::HealthCheckResponse_ServingStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::filestream::HealthCheckResponse_ServingStatus>() {
  return ::filestream::HealthCheckResponse_ServingStatus_descriptor();
}
template <> struct is_proto_enum< ::filestream::HashAlgorithm> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::filestream::HashAlgorithm>() {
  return ::filestream::HashAlgorithm_descriptor();
}
template <> struct is_proto_enum< ::filestream::SizeUnits> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::filestream::SizeUnits>() {
  return ::filestream::SizeUnits_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_FileStream_2eproto
